{Author: Galkov A.V
 Group: 115
 Этап: 2
 Task: 1)Поиск точки пресечения функций f(x)=5/x и g(x)=2.5*x-9.5
         Комбинированный метод
       2)Вычисление интеграла от функции f(x)=5/x
         Квадратурная формула: Формула Симпсона}
program prog(input,output);
{[a,b] - промежуток, на котором процедура root  ищет корень функции F1(x),
         а функция integral вычисляет значение интеграла функции F2(x);
 eps1 - точность нахождения корня функции F1(X);
 eps2 - точность нахождения величины интеграла функции F2(x);
 int - переменная, которой присваивается величина интеграла функции F2(x)
 x - переменная, которой присваивается значение корня функции F1(x)
 k - число итераций}
var     a,b,eps1,eps2,int,x:real;
        k:integer;
{Структура программы:
 1) процедура root поиска корня функции F1(x)=f(x)-g(x),
    где f(x)=5/x и g(x)=2.5*x-9.5
 2) функция integral вычисления определенного интеграла функции F2(x)=5/x

{Процедура root ищет точку пересечения функций f(x)=5/x и g(x)=2.5*x-9.5,
 используя комбинированный метод: одновременно используются метод хорд и
 метод касательных.
 В своей работе использует функции
 F1(x:real):real - вычисляет значение функции F1(x)=f(x)-g(x),
                   где f(x)=5/x и g(x)=2.5*x-9, в точке x;
 f_pr(x:real):real - вычисляет значение первой производной функции
                     F1(x)=f(x)-g(x), где f(x)=5/x и g(x)=2.5*x-9, в точке x;}

procedure root(var a,b,eps1,x:real; var k:integer);
var c1,c2,help:real;
{Функция для вычисления значения F1(x)=f(x)-g(x) в точке}
function F1(x:real):real;
begin
 F1:=2.5*x-9.5-5/x;
end;
{Функция для вычисления значения первой производной в точке x}
function f_pr(x:real):real;
begin
 f_pr:=(2.5*sqr(x)+5)/sqr(x);
end;

begin
 if F1(a)*F1(b)>0
    then writeln('Корней нет')
    else
     begin
      if ( F1(a)<0 ) and ( F1( (a+b)/2 )<( F1(a)+F1(b) ) / 2) or
         ( F1(a)>0 ) and ( F1( (a+b)/2 )>( F1(a)+F1(b) ) / 2)
         then
         else begin
               help:=a;
               a:=b;
               b:=help;
              end;
      k:=0; {Счетчик итераций}
      repeat
       {Нахождение новых граничных точек}
       c1:=(a*F1(b)-b*F1(a))/(F1(b)-F1(a));
       c2:=b-F1(b)/f_pr(b);
       a:=c1;
       b:=c2;
       k:=k+1;
      until abs(b-a)<eps1;
      x:=(b+a)/2;
      writeln('Номер итерации: ',k,', приблизительное значение корня:',x:10:3);
     end;
end;

{Функция integral вычисляет величину определенного интеграла
 функции F2(x)=5/x на отрезке [a,b] с точностью eps2.
 Вычисление осуществляется по формуле Симпсона.
 Заданная точность считается достигнутой, если модуль разности величин
 интегралов при количествах разбиений n и 2n, умноженный на 1/15
 меньше eps2.
 В своей работе использует функцию
 F2(x:real):real, вычисляющую значение функции F2(x)=5/x в точке x}
function integral(var a,b,eps2:real; var k:integer):real;
{ n - число разбиений
  intn - величина интеграла при n разбиений
  int2n - величина интеграла при 2n разбиений}
var      n,i:integer;
         intn,int2n,s,p:real;
{Функция для вычисления значения F2(x)=5/x в точке}
function F2(x:real):real;
begin
 F2:=5/x;
end;

begin
 k:=0;                         { - счетчик итераций}
 n:=1;                         { - начальное количество разбиений}
 int2n:=(F2(a)+F2(b))*(b-a)/3; { - начальное значение интеграла}
 s:=0;                         { - переменная для подсчета промежуточных сумм}
 p:=(b-a)/n;     { - начальная длина отрезков, на которые разбивается [a,b]}
 repeat
  { присваиваем предыдущему значению интеграла более точное}
  intn:=int2n;
  { изменяем коэффициенты для подсчета более точного значения итеграла}
  int2n:=int2n*3/p - 2*s;
  s:=0;
  { увеличиваем число разбиений}
  n:=n*2;
  { вычисляем новую длину отрезков}
  p:=(b-a)/n;
  {Считаем сумму дополнительных значений функции}
  for i:=1 to n-1 do
                    begin
                     if i mod 2 =1 then s:=s + F2(a+i*p);
                    end;
  {Вычисляем более точное значение интеграла}
  int2n:=(int2n + 4*s)*p/3;
  k:=k+1;
 until 1/15*abs(Intn-Int2n)<eps2;
 integral:=int2n;            {Окончательное значение интеграла}
end;

begin
 writeln('Поиск точки пресечения функций f(x)=5/x и g(x)=2.5*x-9.5');
 write('Введите точность вычислений: ');
 readln(eps1);
 writeln('Введите промежуток монотонности функции, на котором ищются корни');
 write('Начало и конец через пробел (не равны нулю и одного знака): ');
 readln(a,b);
 root(a,b,eps1,x,k);
 writeln('Вычисление интеграла функции f(x)=5/x');
 write('Введите точность вычислений: ');
 readln(eps2);
 writeln('Введите промежуток для вычисления интеграла');
 write('Начало и конец через пробел (не равны нулю и одного знака): ');
 readln(a,b);
 int:=integral(a,b,eps2,k);
 writeln('Окончательный результат');
 write('Номер итерации: ',k);
 writeln(', приблизительное значение интеграла:',int:13:3);
 writeln('Нажмите Enter');
 readln                   {Даем пользователю полюбоваться результатом}
end.