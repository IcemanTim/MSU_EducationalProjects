program integral2(input,output);
{Попова Елизавета 114гр}
{Программа поиска корней функции F1(x)=x*x*x-2*x*x-19*x+20 комбинированным методом
и вычисления определенного интеграла функции F11(x)=3*x*x-4*x-19 при помощи формулы трапеций.
Функция F1(x)=x*x*x-2*x*x-19*x+20 имеет разложение F1(x)=(x-1)(x-5)(x+4).
Функция F11(x) - производная функции F1(x)}
type
    Fun=function(x:real):real;
var
  I,a,b,eps1,eps2,x:real;
  kr,ki:integer;
{$F+}
function f1(x:real):real;
begin
     f1:=x*x*x-2*x*x-19*x+20;
end;
function f11(x:real):real;
begin
     f11:=3*x*x-4*x-19;
end;
{******* Процедура нахождения корня функции F1(x) комбинированным методом *******}
procedure root(f1:Fun; a,b,eps1:real; var x:real; var k:integer);
            {Переменную k не могу сделать локальной, тк значение k у меня выводит основная программа, а не сама процедура}
var
   c1,c2:real;  {с1 для метода хорд, с2 для метода касательных}
begin
     k:=0;
     while abs(a-b)>eps1 do
     begin
           c1:=(a*f1(b)-b*f1(a))/(f1(b)-f1(a));
           if ((f1(a)<0) and (f1((a+b)/2)<(f1(a)+f1(b))/2) or ((f1(a)>0) and (f1((a+b)/2)>(f1(a)+f1(b))/2))) then
              begin
                   a:=c1;
                   c2:=b-f1(b)/f11(b);
                   b:=c2;
                   k:=k+1;
              end
           else
               begin
                    b:=c1;
                    c2:=a-f1(a)/f11(a);
                    a:=c2;
                    k:=k+1;
               end;
     end;
     x:=a;
end;
function integral(f11:Fun; a,b,eps2:real; var  k:integer):real;
{******* Вычисление интеграла с помощью формулы трапеций на отрезке [a,b] с точностью eps2*******}
{******* Точность считается достигнутой, когда на очередном шаге величина p*abs(I1-I2) окажется меньше eps2*******}
const
     p=1/3;
var
   h,I1,I2:real;
   n,j:integer;
begin
     n:=10;
     h:=(b-a)/n;
     I1:=h*0.5*(f11(a)+f11(b));
     for j:=1 to n-1 do
     I1:=I1+h*f11(a+j*h);
     I2:=I1;
     k:=0;
     repeat {Чтобы не пересчитывать значения Fi, вычисленные ранее для суммы In, я разбиваю формулу на части
             и вычисляю только те значения, которых "не хватает", а полученные ранее делю пополам и прибавляю}
           I1:=I2;
           I2:=h*0.5*f11(a+h*0.5);
           for j:=1 to n-1 do
               I2:=I2+h*0.5*f11(a+h*0.5+j*h);
           I2:=I2+I1*0.5;
           h:=h*0.5;
           n:=n*2;
           k:=k+1;
     until (p*abs(I1-I2))<eps2;
     integral:=I2;
end;
(************* Основная часть программы ***************)
begin
     writeln('Введите отрезок для подсчета корня');
     read(a,b);
     writeln('Введите точность для подсчета корня');
     readln(eps1);
     root(f1,a,b,eps1,x,kr);
     Writeln('Число итераций =',kr:3,' корень уравнения = ',x:7:3);
     readln;
     writeln('Введите отрезок для подсчета интеграла функции');
     read(a,b);
     writeln('Введите точность для подсчета интеграла функции');
     readln(eps2);
     I:=integral(f11,a,b,eps2,ki);
     writeln('Число итераций =', ki:3,' интеграл = ',I:7:3);
end.













