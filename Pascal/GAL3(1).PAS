{Author: Galkov A.V
 Group: 115
 Этап: 3}
program prog(input,output);
{**************************************************************************
Структура программы:
 1) процедура root поиска корня функции f(x);
 2) функция integral вычисления определенного интеграла функции f(x);
 3) основная программа подсчета и вывода всех значений.
**************************************************************************}

const n=1; m=10; eps1=0.0001; eps2=0.0001;
type  TF=function(x:real):real;
var   S,x12,x13,x23:real;
{**************************************************************************
 S - площадь фигуры, ограниченной тремя кривыми, заданными функциями
     h1(x)=3*(0.5/(x+1)+1), h2(x)=5/x и h3(x)=2.5x-9.5;
 x12 - точка пересечения функций h1(x)=3*(0.5/(x+1)+1) и h2(x)=5/x;
 x13 - точка пересечения функций h1(x)=3*(0.5/(x+1)+1) и h3(x)=2.5x-9.5;
 x23 - точка пересечения функций h2(x)=5/x и h3(x)=2.5x-9.5;
 [n,m] - сегмент, на котором ищется корень функции f(x);
 eps1 - точность вычисления корня функции f(x);
 eps2 - точность вычисления определенного интеграла функции f(x);
**************************************************************************}


{**************************************************************************
{Процедура root ищет корень функции f(x), используя комбинированный метод:
 одновременно используются метод хорд и метод касательных.
 В своей работе использует функции:
 f1(x:real):real - вычисляет в точке x значение функции f1(x)=h1(x)-h2(x),
                   где h1(x)=3*(0.5/(x+1)+1) и h2(x)=5/x;

 f2(x:real):real - вычисляет в точке x значение функции f1(x)=h1(x)-h3(x),
                   где h1(x)=3*(0.5/(x+1)+1) и h3(x)=2.5x-9.5;

 f3(x:real):real - вычисляет в точке x значение функции f1(x)=h3(x)-h2(x),
                   где h2(x)=5/x и h3(x)=2.5x-9.5;

 g1(x:real):real - вычисляет в точке x значение первой производной функции
                   f(x)=h1(x)-h2(x), где h1(x)=3*(0.5/(x+1)+1) и h2(x)=5/x;

 g2(x:real):real - вычисляет в точке x значение первой производной функции
                   f(x)=h1(x)-h3(x), h1(x)=3*(0.5/(x+1)+1) и
                   h3(x)=2.5x-9.5;

 g3(x:real):real;  вычисляет в точке x значение первой производной функции
                   f(x)=h3(x)-h2(x), h2(x)=5/x и h3(x)=2.5x-9.5;
****************************************************************************}

{$F+}
function f1(x:real):real;
begin
 f1:=3*(0.5/(x+1)+1)-5/x;
end;

{$F+}
function f2(x:real):real;
begin
 f2:=1.5/(x+1)-2.5*x+12.5;
end;

{$F+}
function f3(x:real):real;
begin
 f3:=2.5*x-9.5-5/x;
end;

{$F+}
function g1(x:real):real;
begin
 g1:=-1.5/sqr(x+1)+5/sqr(x);
end;

{$F+}
function g2(x:real):real;
begin
 g2:=-1.5/sqr(x+1)-2.5;
end;

{$F+}
function g3(x:real):real;
begin
 g3:=2.5+5/sqr(x)
end;

procedure root(f,g:TF; var x:real);
var a,b,help:real;
{*************************************************************************
 f,g - параметры-функции;
 [a,b] - отрезок, на котором процедура root ищет корень функции f(x)
 x - корень функции f(x);
*************************************************************************}
begin
 a:=n;
 b:=m;
 if ( f(a)<0 ) and ( f( (a+b)/2 )<( f(a)+f(b) ) / 2) or
    ( f(a)>0 ) and ( f( (a+b)/2 )>( f(a)+f(b) ) / 2)
    then
    else begin
          help:=a;
          a:=b;
          b:=help;
         end;
 repeat
 {Нахождение новых граничных точек}
  a:=(a*f(b)-b*f(a))/(f(b)-f(a));
  b:=b-f(b)/g(b);
 until abs(b-a)<eps1;
 x:=(b+a)/2;
end;

{****************************************************************************
 Функция integral вычисляет величину определенного интеграла функции f(x).
 Вычисление осуществляется по формуле Симпсона.
 Заданная точность считается достигнутой, если модуль разности величин
 интегралов при количествах разбиений n и 2n, умноженный на 1/15
 меньше eps2.
 Алгоритм работы функции:
 1) задаем начальное количество разбиений n=1;
 2) задаем начальное значение интеграла;
 3) переменной для подсчета промежуточных сумм присваиваем значение 0;
 4) вычисляем начальную длину отрезков, на которые разбивается [a,b];
 5) цикл. Условие: до тех пор, когда модуль разности величин интегралов
    при количествах разбиений n и 2n, умноженный на 1/15, станет меньше eps2;
 5.1) присваиваем значению интеграла при n разбиений значение, полученное
      на предыдущем шаге цикла;
 5.2) дополнительные значения функций s, вычисленные на предыдущем шаге
      цикла, будут входить в новое значение интеграла уже с коэффициентом 2
      (до этого входили с коэффициентом 4), поэтому из значения интеграла,
      вычисленного на предыдущем шаге цикла, необходимо вычесть 2*s;
 5.3) увеличиваем число разбиений в два раза;
 5.4) вычисляем новую длину отрезков в соответствии с новым разбиением;
 5.5) в цикле считаем сумму s дополнительных значений функции, появившихся
      в связи с увеличением числа разбиений;
 5.6) вычисляем более точное значение интеграла, прибавляя к старому
      вычисленные на прошлом шаге дополнительные значения функций с
      коэффициентом 4;
 6) после выхода из цикла получаем окончательное значение интеграла.
 В своей работе использует функции:
 1) f1(x:real):real;
 2) f2(x:real):real.
****************************************************************************}

function integral(f:TF; a,b:real):real;
var n,i:integer;
    intn,int2n,s,p:real;
{****************************************************************************
 [a,b] - отрезок, на котором вычисляется значение интеграла функции f(x);
 n - число разбиений
 intn - величина интеграла при n разбиений
 int2n - величина интеграла при 2n разбиений
****************************************************************************}

begin
 n:=1;                         {1}
 int2n:=(f(a)+f(b))*(b-a)/3;   {2}
 s:=0;                         {3}
 p:=(b-a);                     {4}
 repeat                        {5}
  intn:=int2n;                 {5.1}
  int2n:=int2n*3/p - 2*s;      {5.2}
  s:=0;
  n:=n*2;                      {5.3}
  p:=(b-a)/n;                  {5.4}
  for i:=1 to n-1 do           {5.5}
      if i mod 2 =1 then s:=s + f(a+i*p);
  int2n:=(int2n + 4*s)*p/3;    {5.6}
 until 1/15*abs(Intn-Int2n)<eps2;
 integral:=int2n;              {6}
end;

begin
 writeln('Абсцисcы точек пересечения функций:');
{Точки ищутся на отрезке [n,m] с точностью eps1}

{Поиск точки пересечения функций h1(x)=3*(0.5/(x+1)+1) и h2(x)=5/x}
 root(f1,g1,x12);
 write('1) h1(x)=3*(0.5/(x+1)+1)  и  h2(x)=5/x:');
 writeln(x12:15:4);

{Поиск точки пересечения функций h1(x)=3*(0.5/(x+1)+1) и h3(x)=2.5x-9.5}
 root(f2,g2,x13);
 write('2) h1(x)=3*(0.5/(x+1)+1)  и  h3(x)=2.5x-9.5:');
 writeln(x13:10:4);

{Поиск точки пересечения функций h2(x)=5/x и h3(x)=2.5x-9.5}
 root(f3,g3,x23);
 write('3) h2(x)=5/x              и  h3(x)=2.5x-9.5:');
 writeln(x23:10:4);
 writeln;

{*************************************************************************
 Вычисляем с точность 0.001 площадь фигуры, ограниченной тремя кривыми,
 заданными функциями h1(x)=3*(0.5/(x+1)+1), h2(x)=5/x и h3(x)=2.5x-9.5,
 как сумму двух интегралов:
 1) определенный интеграл от функции f1(x)=h1(x)-h2(x)
 на отрезке [x12,x23], где h1(x)=3*(0.5/(x+1)+1) и h2(x)=5/x
 2) определенный интеграл от функции f2(x)=h1(x)-h3(x)
 на отрезке [x23,x13], где h1(x)=3*(0.5/(x+1)+1) и h3(x)=2.5x-9.5
*************************************************************************}

 S:=integral(f1,x12,x23) + integral(f2,x23,x13);
 writeln('Площадь фигуры, ограниченной тремя кривыми,');
 writeln('заданными функциями');
 writeln('h1(x)=3*(0.5/(x+1)+1),');
 writeln('h2(x)=5/x и');
 writeln('h3(x)=2.5x-9.5');
 writeln('приблизительно равна:',S:33:3);

{Даем пользователю возможность посмотреть результат}
 writeln('Нажмите Enter');
 readln
end.